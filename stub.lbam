val %( + ) : Int -> Int -> Int
  external (builtin = "int_add", surface = "+")
val %( - ) : Int -> Int -> Int
  external (builtin = "int_sub", surface = "-")
val %( * ) : Int -> Int -> Int
  external (builtin = "int_mult", surface = "*")
val %( // ) : Int -> Int -> Int
  external (builtin = "int_div", surface = "//")
val %( +. ) : Float -> Float -> Float
  external (builtin = "float_add", surface = "+.")
val %( -. ) : Float -> Float -> Float
  external (builtin = "float_sub", surface = "-.")
val %( / ) : Float -> Float -> Float
  external (builtin = "float_div", surface = "/")
val %mod : Int -> Int -> Int
  external (builtin = "int_mod", surface = "mod")
val %( <= ) : Int -> Int -> Bool
  external (builtin = "int_leq", surface = "<=")
val %( >= ) : Int -> Int -> Bool
  external (builtin = "int_geq", surface = ">=")
val %( < ) : Int -> Int -> Bool
  external (builtin = "int_lt", surface = "<")
val %( > ) : Int -> Int -> Bool
  external (builtin = "int_gt", surface = ">")
val %( == ) : Int -> Int -> Bool
  external (builtin = "int_equal", surface = "==")
val %( && ) : Bool -> Bool -> Bool
  external (builtin = "and", surface = "&&")
val %( || ) : Bool -> Bool -> Bool
  external (builtin = "or", surface = "||")
val %( :: ) : forall 'a -> 'a -> List 'a -> List 'a
  external (builtin = "cons", surface = "::")
val %sqrt : Float -> Float
  external (builtin = "sqrt", surface = "sqrt")
val %float : Int -> Float
  external (builtin = "float", surface = "float")
val neg_infinity = float -1 / 0.0
val print_int : Int -> Unit
  external (builtin = "print_int", surface = "print_int")
val print_float : Float -> Unit
  external (builtin = "print_float", surface = "print_float")
val print_string : String -> Unit
  external (builtin = "print_string", surface = "print_string")
val %range : Int -> Int -> List Int
  external (builtin = "range", surface = "range")
val %fst : forall 'a -> forall 'b -> 'a * 'b -> 'a
  external (builtin = "fst", surface = "fst")
val %snd : forall 'a -> forall 'b -> 'a * 'b -> 'b
  external (builtin = "snd", surface = "snd")
val %( ++ ) : String -> String -> String
  external (builtin = "string_append", surface = "++")
val %show_int : Int -> String
  external (builtin = "show_int", surface = "show_int")
val %show_float : Float -> String
  external (builtin = "show_float", surface = "show_float")

val ~lift_int : Int -> &Int
  external (builtin = "lift_int", surface = "lift_int")
val ~lift_string : String -> &String
  external (builtin = "lift_string", surface = "lift_string")

val ~insert_at : Nat -> Nat -> List Nat -> List Nat
  external (builtin = "insert_at", surface = "insert_at")
val ~drop_at : Nat -> List Nat -> List Nat
  external (builtin = "drop_at", surface = "drop_at")
val ~swap : Int -> Int -> List Nat -> List Nat
  external (builtin = "swap", surface = "swap")
val ~dim_matmul : List Nat -> List Nat -> List Nat
  external (builtin = "dim_matmul", surface = "dim_matmul")
val %prod : List Int -> Int
  external (builtin = "prod", surface = "prod")
val ~broadcastable : List Nat -> List Nat -> Bool
  external (builtin = "broadcastable", surface = "broadcastable")
val ~broadcast : List Nat -> List Nat -> List Nat
  external (builtin = "broadcast", surface = "broadcast")
(* TODO: make `reshapeable` support `-1` *)
val ~reshapeable : List Nat -> List Nat -> Bool
  external (builtin = "reshapeable", surface = "reshapeable")

val ~gen_vadd : {a : Nat} -> &(Vec %a -> Vec %a -> Vec %a)
  external (builtin = "gen_vadd", surface = "vadd")
val ~gen_vconcat : {a : Nat} -> {b : Nat} -> &(Vec %a -> Vec %b -> Vec %(a + b))
  external (builtin = "gen_vconcat", surface = "vconcat")
val ~gen_mtranspose : {a : Nat} -> {b : Nat} -> &(Mat %a %b -> Mat %b %a)
  external (builtin = "gen_mtranspose", surface = "mtranspose")
val ~gen_mmult : {a : Nat} -> {b : Nat} -> {c : Nat} -> &(Mat %a %b -> Mat %b %c -> Mat %a %c)
  external (builtin = "tensor__gen_mm", surface = "mmult")
    (* TODO: replace this with `Tensor.gen_mm` *)
val ~gen_mconcat_vert : {a : Nat} -> {b : Nat} -> {c : Nat} -> &(Mat %a %c -> Mat %b %c -> Mat %(a + b) %c)
  external (builtin = "gen_mconcat_vert", surface = "mconcat_vert")

module String = struct
  val %concat : #sep String -> List String -> String
    external (builtin = "string__concat", surface = "concat")
  val %from_char_list : List Char -> String
    external (builtin = "string__from_char_list", surface = "from_char_list")
end

module List = struct
  val %map : forall 'a -> forall 'b -> ('a -> 'b) -> List 'a -> List 'b
    external (builtin = "list__map", surface = "map")
  val %rev_map : forall 'a -> forall 'b -> ('a -> 'b) -> List 'a -> List 'b
    external (builtin = "list__rev_map", surface = "rev_map")
  val %append : forall 'a -> List 'a -> List 'a -> List 'a
    external (builtin = "list__append", surface = "append")
  val %iter : forall 'a -> ('a -> Unit) -> List 'a -> Unit
    external (builtin = "list__iter", surface = "iter")
  val %length : forall 'a -> List 'a -> Int
    external (builtin = "list__length", surface = "length")
  val %initialize : forall 'a -> Int -> (Int -> 'a) -> List 'a
    external (builtin = "list__initialize", surface = "initialize")
  val %equal : forall 'a -> ('a -> 'a -> Bool) -> List 'a -> List 'a -> Bool
    external (builtin = "list__equal", surface = "equal")
  val ~tail : forall 'a -> {xs : List 'a | length xs >= 1} -> List 'a
    external (builtin = "list__tail", surface = "tail")
  val ~init : forall 'a -> {xs : List 'a | length xs >= 1} -> List 'a
    external (builtin = "list__init", surface = "init")
  val ~last : forall 'a -> {xs : List 'a | length xs >= 1} -> 'a
    external (builtin = "list__last", surface = "last")
  val ~nth : forall 'a -> (i : Nat) -> {xs : List 'a | length xs > i} -> 'a
    external (builtin = "list__nth", surface = "nth")
end

module Gc = struct
  val full_major : Unit -> Unit
    external (builtin = "gc__full_major", surface = "full_major")
end

module IO = struct
  val write_all : String -> #data String -> Unit
    external (builtin = "io__write_all", surface = "write_all")
  module OutChannel = struct
    val with_file : String -> (OutChannel -> Unit) -> Unit
      external (builtin = "io__out_channel__with_file", surface = "with_file")
    val output_string : OutChannel -> String -> Unit
      external (builtin = "io__out_channel__output_string", surface = "output_string")
  end
end

module Unix = struct
  val gettimeofday : Unit -> Int
    external (builtin = "unix__gettimeofday", surface = "gettimeofday")
end

module Device = struct
  val cpu : Device
    external (builtin = "device__cpu", surface = "cpu")
  val ~gen_cuda_if_available : Unit -> &Device
    external (builtin = "device__gen_cuda_if_available", surface = "cuda_if_available")
end

module Tensor = struct
  val ~gen_zeros : (shape : List Nat) -> &(Tensor %shape)
    external (builtin = "tensor__gen_zeros", surface = "zeros")
  val ~gen_ones : (shape : List Nat) -> &(Tensor %shape)
    external (builtin = "tensor__gen_ones", surface = "ones")
  val ~gen_copy : {shape : List Nat} -> &(Tensor %shape -> Tensor %shape)
    external (builtin = "tensor__gen_copy", surface = "copy")
  val ~gen_add :
    {shape1 : List Nat} -> {shape2 : {s : List Nat | broadcastable shape1 s}} ->
    &(Tensor %shape1 -> Tensor %shape2 -> Tensor %(broadcast shape1 shape2))
    external (builtin = "tensor__gen_add", surface = "+")
  val ~gen_sub :
    {shape1 : List Nat} -> {shape2 : {s : List Nat | broadcastable shape1 s}} ->
    &(Tensor %shape1 -> Tensor %shape2 -> Tensor %(broadcast shape1 shape2))
    external (builtin = "tensor__gen_sub", surface = "-")
  val ~gen_mult :
    {shape1 : List Nat} -> {shape2 : {s : List Nat | broadcastable shape1 s}} ->
    &(Tensor %shape1 -> Tensor %shape2 -> Tensor %(broadcast shape1 shape2))
    external (builtin = "tensor__gen_mult", surface = "*")
  val ~gen_div :
    {shape1 : List Nat} -> {shape2 : {s : List Nat | broadcastable shape1 s}} ->
    &(Tensor %shape1 -> Tensor %shape2 -> Tensor %(broadcast shape1 shape2))
    external (builtin = "tensor__gen_div", surface = "/")
  val ~gen_log :
    {shape : List Nat} -> &(Tensor %shape -> Tensor %shape)
    external (builtin = "tensor__gen_log", surface = "log")
  val ~gen_square :
    {shape : List Nat} -> &(Tensor %shape -> Tensor %shape)
    external (builtin = "tensor__gen_square", surface = "square")
  val ~gen_cat_ :
    #dim (dim : Int) ->
    {shape1 : {s : List Nat | List.length s > dim}} ->
    {shape2 : {s : List Nat | List.length s > dim && List.equal (==) (drop_at dim s) (drop_at dim shape1)}} ->
    &(Tensor %shape1 ->
      Tensor %shape2 ->
      Tensor %(insert_at dim (List.nth dim shape1 + List.nth dim shape2) (drop_at dim shape1))
    )
    external (builtin = "tensor__gen_cat_", surface = "cat_")
  val ~gen_mean :
    {shape : List Nat} -> &(Tensor %shape -> Tensor %[])
    external (builtin = "tensor__gen_mean", surface = "mean")
  val ~gen_rand :
    (* #requires_grad Bool -> *) (* default: false *)
    (* #kind Kind -> *)
    (* #device Device -> *)
    (* #scale Float -> *) (* default: 1.0 *)
    (shape : List Nat) ->
    &(Tensor %shape)
    external (builtin = "tensor__gen_rand", surface = "rand")
  val ~gen_float_vec :
    (* #kind Kind -> *)
    (* #device Device -> *)
    (floats : List Float) -> &(Tensor %[List.length floats])
    external (builtin = "tensor__gen_float_vec", surface = "float_vec")
  val ~gen_grad : {shape : List Nat} -> &(Tensor %shape -> Tensor %shape)
    external (builtin = "tensor__gen_grad", surface = "grad")
  val ~gen_zero_grad : {shape : List Nat} -> &(Tensor %shape -> Unit)
    external (builtin = "tensor__gen_zero_grad", surface = "zero_grad")
  val ~gen_mm : {a : Nat} -> {b : Nat} -> {c : Nat} -> &(Mat %a %b -> Mat %b %c -> Mat %a %c)
    external (builtin = "tensor__gen_mm", surface = "mm")
  val ~gen_add_update : {shape : List Nat} -> &(Tensor %shape -> Tensor %shape -> Unit)
    external (builtin = "tensor__gen_add_update", surface = "+=")
  val ~gen_sub_update : {shape : List Nat} -> &(Tensor %shape -> Tensor %shape -> Unit)
    external (builtin = "tensor__gen_sub_update", surface = "-=")
  val ~gen_scatter_ :
    {src_shape : List Nat} ->
    {index_shape : List Nat} ->
    {shape : List Nat} ->
    #dim Int ->
    &(#src Tensor %src_shape ->
      #index Tensor %index_shape ->
      Tensor %shape ->
      Tensor %shape
    )
    external (builtin = "tensor__gen_scatter_", surface = "scatter_")
  val ~gen_argmax : {shape : List Nat} -> (dim : Nat) -> &(Tensor %shape -> Tensor %(drop_at dim shape))
    external (builtin = "tensor__gen_argmax", surface = "argmax")
  val ~gen_cross_entropy_for_logits :
    {m : Nat} -> {n : Nat} ->
    &(Tensor %[m, n] -> #targets Tensor %[m] -> Tensor %[])
    external (builtin = "tensor__gen_cross_entropy_for_logits", surface = "cross_entropy_for_logits")
  val ~gen_multinomial :
    {shape : {s : List Nat | List.length s >= 1}} ->
    #num_samples (num_samples : Nat) ->
    &(#replacement Bool ->
      Tensor %shape ->
      Tensor %(List.append (List.init shape) [num_samples])
    )
    external (builtin = "tensor__gen_multinomial", surface = "multinomial")
  val ~gen_count_equal : {shape : List Nat} -> &(Tensor %shape -> Tensor %shape -> Int)
    external (builtin = "tensor__gen_count_equal", surface = "count_equal")
  val f : Float -> Tensor %[]
    external (builtin = "tensor__f", surface = "f")
  val backward : Tensor %[] -> Unit
    external (builtin = "tensor__backward", surface = "backward")
  val no_grad : (Unit -> Unit) -> Unit
    external (builtin = "tensor__no_grad", surface = "no_grad")
  val ~gen_float_value :
    {shape : {s : List Nat | prod s == 1}} ->
    &(Tensor %shape -> Float)
    external (builtin = "tensor__gen_float_value", surface = "float_value")
  val ~gen_int_value :
    {shape : {s : List Nat | prod s == 1}} ->
    &(Tensor %shape -> Int)
    external (builtin = "tensor__gen_int_value", surface = "int_value")
  val ~gen_tril :
    {shape : {s : List Nat | List.length s == 2}} ->
    &(#diagonal Int ->
      Tensor %shape ->
      Tensor %shape
    )
    external (builtin = "tensor__gen_tril", surface = "tril")
  val ~gen_contiguous :
    {shape : List Nat} ->
    &(Tensor %shape ->
      Tensor %shape
    )
    external (builtin = "tensor__gen_contiguous", surface = "contiguous")
  val ~gen_eq_scalar :
    {shape : List Nat} ->
    &(Tensor %shape ->
      Tensor %[] ->
      Tensor %shape
    )
    external (builtin = "tensor__gen_eq_scalar", surface = "eq_scalar")
  val ~gen_get :
    {shape : List Nat} ->
    &(Tensor %shape -> Int -> Tensor %(List.tail shape))
    external (builtin = "tensor__gen_get", surface = "get")
  (* Note: MAY FAIL AT RUNTIME DUE TO INDICES OUT OF BOUNDS!: *)
  val ~gen_get_float2_unsafe :
    {shape : {s : List Nat | List.length s == 2}} ->
    &(Tensor %shape -> Int -> Int -> Float)
    external (builtin = "tensor__gen_get_float2_unsafe", surface = "get_float2_unsafe")
  val ~gen_fill_float : {shape : List Nat} -> &(Tensor %shape -> Float -> Unit)
    external (builtin = "tensor__gen_fill_float", surface = "fill_float")
  val ~gen_dropout :
    {shape : List Nat} ->
    &(#p Float -> (* dropout prob *)
      #is_training Bool ->
      Tensor %shape ->
      Tensor %shape
    )
    external (builtin = "tensor__gen_dropout", surface = "dropout")
  val ~gen_gelu :
    {shape : List Nat} ->
    &(Tensor %shape ->
      Tensor %shape
    )
    external (builtin = "tensor__gen_gelu", surface = "gelu")
  val ~gen_relu :
    {shape : List Nat} ->
    &(Tensor %shape ->
      Tensor %shape
    )
    external (builtin = "tensor__gen_relu", surface = "relu")
  val ~gen_leaky_relu :
    {shape : List Nat} ->
    &(Tensor %shape ->
      Tensor %shape
    )
    external (builtin = "tensor__gen_leaky_relu", surface = "leaky_relu")
  (* TODO: make `gen_reshape` support `-1` *)
  val ~gen_reshape :
    {shape1 : List Nat} ->
    #shape (shape2 : {sh : List Nat | reshapeable shape1 sh}) ->
    &(Tensor %shape1 -> Tensor %shape2)
    external (builtin = "tensor__gen_reshape", surface = "reshape")
  val ~gen_view :
    {shape1 : List Nat} ->
    #size (shape2 : {sh : List Nat | reshapeable shape1 sh}) ->
    &(Tensor %shape1 -> Tensor %shape2)
    external (builtin = "tensor__gen_view", surface = "view")
  val ~gen_narrow :
    {shape : List Nat} ->
    #dim (dim : Nat) ->
    #length (length : Nat) ->
    &(#start Int -> Tensor %shape -> Tensor %(insert_at dim length (drop_at dim shape)))
    external (builtin = "tensor__gen_narrow", surface = "narrow")
  val ~gen_select :
    #dim (dim : Nat) ->
    {shape : {s : List Nat | List.length s > dim}} ->
    &(#index Int ->
      Tensor %shape ->
      Tensor %(drop_at dim shape)
    )
    external (builtin = "tensor__gen_select", surface = "select")
  val ~gen_transpose :
    {shape : List Nat} ->
    #dim0 (dim0 : {n : Int | n >= 0 - List.length shape && n < List.length shape}) ->
    #dim1 (dim1 : {n : Int | n >= 0 - List.length shape && n < List.length shape}) ->
    &(Tensor %shape ->
      Tensor %(swap dim0 dim1 shape)
    )
    external (builtin = "tensor__gen_transpose", surface = "transpose")
  val ~gen_matmul :
    {shape1 : {s : List Nat | List.length s >= 2}} ->
    {shape2 :
      {s : List Nat |
        List.length s >= 2
          && broadcastable (List.init (List.init shape1)) (List.init (List.init s))
          && List.last shape1 == List.nth (List.length s - 2) s
      }
    } ->
    &(Tensor %shape1 ->
      Tensor %shape2 ->
      Tensor
        %(List.append
            (broadcast (List.init (List.init shape1)) (List.init (List.init shape2)))
            (dim_matmul shape1 shape2)
        )
    )
    external (builtin = "tensor__gen_matmul", surface = "matmul")
  val ~gen_masked_fill :
    {shape1 : List Nat} ->
    {shape2 : {s : List Nat | broadcastable shape1 s}} ->
    &(#mask Tensor %shape1 ->
      #value Tensor %[] ->
      Tensor %shape2 ->
      Tensor %(broadcast shape1 shape2)
    )
    external (builtin = "tensor__gen_masked_fill", surface = "masked_fill")
  val ~gen_max_pool2d :
    {k : Nat} ->
    {l : Nat} ->
    {m : Nat} ->
    {n : Nat} ->
    #padding (padding : Int * Int) ->
    #ksize (ksize : Int * Int) ->
    #stride (stride : Int * Int) ->
    &(Tensor %[k, l, m, n] ->
      Tensor %[k, l, (m + 2 * fst padding - fst ksize) // fst stride + 1, (n + 2 * snd padding - snd ksize) // snd stride + 1]
    )
    external (builtin = "tensor__gen_max_pool2d", surface = "max_pool2d")
  val ~gen_softmax :
    {ns : List Nat} ->
    #dim Int ->
    &(Tensor %ns -> Tensor %ns)
    external (builtin = "tensor__gen_softmax", surface = "softmax")
  val ~gen_const_batch_norm :
    {shape : List Nat} ->
    (* #momentum Float -> *)
    (* #eps float -> *)
    &(Tensor %shape ->
      Tensor %shape
    )
    external (builtin = "tensor__gen_const_batch_norm", surface = "const_batch_norm")
end

module VarStore = struct
  val create :
    #frozen Bool ->
    #name String ->
    #device Device ->
    Unit -> VarStore
    external (builtin = "var_store__create", surface = "create")
  val freeze : VarStore -> Unit
    external (builtin = "var_store__freeze", surface = "freeze")
  val unfreeze : VarStore -> Unit
    external (builtin = "var_store__unfreeze", surface = "unfreeze")
  val ( / ) : VarStore -> String -> VarStore
    external (builtin = "var_store__slash", surface = "/")
  val ( // ) : VarStore -> Int -> VarStore
    external (builtin = "var_store__double_slash", surface = "//")
  val device : VarStore -> Device
    external (builtin = "var_store__device", surface = "device")
  val ~gen_all_vars : {ns : List Nat} -> &(VarStore -> List (String * Tensor %ns))
    external (builtin = "var_store__gen_all_vars", surface = "all_vars")
  (* TODO: handle `VarStoreInit` by an ADT *)
  val ~gen_new_var :
    #shape (shape : List Nat) ->
    &(VarStore ->
      (* #trainable Bool -> *) (* default: true *)
      #name String ->
      #init VarStoreInit ->
      Tensor %shape
    )
    external (builtin = "var_store__gen_new_var", surface = "new_var")
  module Init = struct
    val zeros : VarStoreInit
      external (builtin = "var_store__init__zeros", surface = "zeros")
  end
end

module Layer = struct
  (* TODO: define `Activation` as an ADT *)
  module Activation = struct
    val relu : Activation
      external (builtin = "layer__activation__relu", surface = "relu")
    val softmax : Activation
      external (builtin = "layer__activation__softmax", surface = "softmax")
    val log_softmax : Activation
      external (builtin = "layer__activation__log_softmax", surface = "log_softmax")
    val tanh : Activation
      external (builtin = "layer__activation__tanh", surface = "tanh")
    val leaky_relu : Activation
      external (builtin = "layer__activation__leaky_relu", surface = "leaky_relu")
    val sigmoid : Activation
      external (builtin = "layer__activation__sigmoid", surface = "sigmoid")
    val none : Activation (* TODO: remove this and use `Maybe` *)
      external (builtin = "layer__activation__none", surface = "none")
  end
  val ~gen_forward :
    {shape1 : List Nat} ->
    {shape2 : List Nat} ->
    &((Tensor %shape1 -> Tensor %shape2) ->
      Tensor %shape1 -> Tensor %shape2
    )
    external (builtin = "layer__gen_forward", surface = "forward")
  val ~gen_forward_ :
    {shape1 : List Nat} ->
    {shape2 : List Nat} ->
    &((#is_training Bool -> Tensor %shape1 -> Tensor %shape2) ->
      #is_training Bool -> Tensor %shape1 -> Tensor %shape2
    )
    external (builtin = "layer__gen_forward_", surface = "forward_")
  val ~gen_of_fn_ :
    {shape1 : List Nat} ->
    {shape2 : List Nat} ->
    &((#is_training Bool -> Tensor %shape1 -> Tensor %shape2) ->
      #is_training Bool -> Tensor %shape1 -> Tensor %shape2
    )
    external (builtin = "layer__gen_of_fn_", surface = "of_fn_")
  val ~gen_conv2d_ :
    #ksize (ksize : Int) ->
    #stride (stride : Int) ->
    #padding (padding : Int) ->
    #input_dim (input_dim : Nat) ->
    #output_dim (output_dim : Nat) ->
    {shape : {s : List Nat | List.length s == 4 && List.nth 1 s == input_dim}} ->
    &(VarStore ->
      Activation ->
      Tensor %shape ->
      Tensor %[
        List.nth 0 shape,
        output_dim,
        (List.nth 2 shape + 2 * padding - ksize) // stride + 1,
        (List.nth 3 shape + 2 * padding - ksize) // stride + 1
      ]
    )
    external (builtin = "layer__gen_conv2d_", surface = "conv2d_")
  val ~gen_conv_transpose2d_ :
    #ksize (ksize : Nat) ->
    #stride (stride : Nat) ->
    #padding (padding : Nat) ->
    #output_padding (output_padding : Nat) -> (* default: 0 *)
    (* #groups Nat -> *)
    #input_dim (input_dim : Nat) ->
    #output_dim (output_dim : Nat) ->
    {shape : {s : List Nat | List.length s == 4 && List.nth 1 s == input_dim}} ->
    &(VarStore ->
      (* #use_bias Bool -> *) (* default: true *)
      (* #w_init VarStore.Init -> *)
      Activation ->
      Tensor %shape ->
      Tensor %[
        List.nth 0 shape,
        output_dim,
        (List.nth 2 shape - 1) * stride - 2 * padding + ksize + output_padding,
        (List.nth 3 shape - 1) * stride - 2 * padding + ksize + output_padding
      ]
    )
    external (builtin = "layer__gen_conv_transpose2d_", surface = "conv_transpose2d_")
  val ~gen_linear :
    {ns : List Nat} ->
    #input_dim (input_dim : Nat) ->
    #output_dim (output_dim : Nat) ->
    &(VarStore ->
      #use_bias Bool -> (* default: true *)
      (* #w_init VarStore.Init -> *)
      Activation ->
      Tensor %(List.append ns [input_dim]) ->
      Tensor %(List.append ns [output_dim])
    )
    external (builtin = "layer__gen_linear", surface = "linear")
  val ~gen_layer_norm :
    (* #cudnn_enable Bool -> *)
    (* #eps Float -> *)
    #dim (dim : Nat) ->
    {shape : {s : List Nat | List.length s >= 1 && List.last s == dim}} ->
    &(VarStore ->
      Tensor %shape ->
      Tensor %shape
    )
    external (builtin = "layer__gen_layer_norm", surface = "layer_norm")
  val ~gen_embeddings :
    {shape : List Nat} ->
    (* #sparse Bool -> *)
    (* #scale_grad_by_freq Bool -> *)
    #num_embeddings Nat ->
    #embedding_dim (embedding_dim : Nat) ->
    &(VarStore ->
      Tensor %shape ->
      Tensor %(List.append shape [embedding_dim])
    )
    external (builtin = "layer__gen_embeddings", surface = "embeddings")
  module Lstm = struct
    val ~gen_create :
      #input_dim (input_size : Nat) ->
      #hidden_size (hidden_size : Nat) ->
      &(VarStore -> Lstm %input_size %hidden_size)
      external (builtin = "layer__lstm__gen_create", surface = "create")
    val ~gen_zero_state :
      {input_size : Nat} ->
      {hidden_size : Nat} ->
      #batch_size (batch_size : Nat) ->
      &(Lstm %input_size %hidden_size ->
        Tensor %[batch_size, hidden_size] * Tensor %[batch_size, hidden_size]
      )
      external (builtin = "layer__lstm__gen_zero_state", surface = "zero_state")
    val ~gen_step :
      {input_size : Nat} ->
      {hidden_size : Nat} ->
      {batch_size : Nat} ->
      &(Lstm %input_size %hidden_size ->
        Tensor %[batch_size, hidden_size] * Tensor %[batch_size, hidden_size] ->
        Tensor %[batch_size, input_size] ->
        Tensor %[batch_size, hidden_size] * Tensor %[batch_size, hidden_size]
      )
      external (builtin = "layer__lstm__gen_step", surface = "step")
    val ~gen_seq :
      {input_size : Nat} ->
      {hidden_size : Nat} ->
      {batch_size : Nat} ->
      {seq_len : Nat} ->
      &(#is_training Bool ->
        Lstm %input_size %hidden_size ->
        Tensor %[batch_size, seq_len, input_size] ->
        Tensor %[batch_size, seq_len, hidden_size]
          * (Tensor %[1, batch_size, hidden_size] * Tensor %[1, batch_size, hidden_size])
      )
      external (builtin = "layer__lstm__gen_seq", surface = "seq")
  end
end

module Optimizer = struct
  val adam :
    VarStore ->
    #learning_rate Float ->
    Optimizer
    external (builtin = "optimizer__adam", surface = "adam")
  val sgd :
    VarStore ->
    #learning_rate Float ->
    #momentum Float ->
    Optimizer
    external (builtin = "optimizer__sgd", surface = "sgd")
  (* TODO: handle `Optimizer.ClipGrad` as an ADT *)
  module ClipGrad = struct
    val none : ClipGrad
      external (builtin = "optimizer__clip_grad__none", surface = "none")
    val norm2 : Float -> ClipGrad
      external (builtin = "optimizer__clip_grad__norm2", surface = "norm2")
    val value : Float -> ClipGrad
      external (builtin = "optimizer__clip_grad__value", surface = "value")
  end
  val step :
    #clip_grad ClipGrad ->
    Optimizer ->
    Unit
    external (builtin = "optimizer__step", surface = "step")
  val zero_grad :
    Optimizer ->
    Unit
    external (builtin = "optimizer__zero_grad", surface = "zero_grad")
  val backward_step :
    #clip_grad ClipGrad -> (* default: Optimizer.ClipGrad.none *)
    Optimizer ->
    #loss Tensor %[] ->
    Unit
    external (builtin = "optimizer__backward_step", surface = "backward_step")
end

module Checkpointing = struct
  val loop :
    #start_index Int ->
    #end_index Int ->
    #var_stores List VarStore ->
    #checkpoint_base String ->
    (* #only_keep Int -> *)
    #checkpoint_every_iters Int -> (* [ `iters of int | `seconds of float ]. default : `seconds 600 *)
    (#index Int -> Unit) ->
    Unit
    external (builtin = "checkpointing__loop", surface = "loop")
end

module DatasetHelper = struct
  val ~gen_train_batch :
    {ntrain : Nat} ->
    {ntest : Nat} ->
    {imgdim : List Nat} ->
    {labeldim : List Nat} ->
    #batch_size (batch_size : Nat) ->
    &(Device ->
      Dataset %ntrain %ntest %imgdim %labeldim ->
      Int ->
      Tensor %(batch_size :: imgdim) * Tensor %(batch_size :: labeldim)
    )
    external (builtin = "dataset_helper__gen_train_batch", surface = "train_batch")
  val ~gen_batch_accuracy :
    {n : Nat} ->
    {ntrain : Nat} ->
    {ntest : Nat} ->
    {imgdim : List Nat} ->
    {labeldim : List Nat} ->
    #batch_size (batch_size : Nat) ->
    &(#predict (Tensor %(batch_size :: imgdim) -> Tensor %[batch_size, n]) ->
      Device ->
      Dataset %ntrain %ntest %imgdim %labeldim ->
      Float
    )
    external (builtin = "dataset_helper__gen_batch_accuracy", surface = "batch_accuracy")
  val ~gen_batches_per_epoch :
    {ntrain : Nat} ->
    {ntest : Nat} ->
    {imgdim : List Nat} ->
    {labeldim : List Nat} ->
    #batch_size (batch_size : Nat) ->
    &(Dataset %ntrain %ntest %imgdim %labeldim -> Int)
    external (builtin = "dataset_helper__gen_batches_per_epoch", surface = "batches_per_epoch")
  val ~gen_iter :
    {ntrain : Nat} ->
    {ntest : Nat} ->
    {imgdim : List Nat} ->
    {labeldim : List Nat} ->
    #batch_size (batch_size : Nat) ->
    &((Tensor %(batch_size :: imgdim) -> Tensor %(batch_size :: labeldim) -> Unit) ->
      Device ->
      Dataset %ntrain %ntest %imgdim %labeldim ->
      Unit
    )
    external (builtin = "dataset_helper__gen_iter", surface = "iter")
  val ~gen_map :
    {ntrain : Nat} ->
    {ntest : Nat} ->
    {imgdim1 : List Nat} ->
    {labeldim1 : List Nat} ->
    {imgdim2 : List Nat} ->
    {labeldim2 : List Nat} ->
    #batch_size (batch_size : Nat) ->
    &(( Tensor %(batch_size :: imgdim1) ->
        Tensor %(batch_size :: labeldim1) ->
        Tensor %(batch_size :: imgdim2) * Tensor %(batch_size :: labeldim2)
      ) ->
      Device ->
      Dataset %ntrain %ntest %imgdim1 %labeldim1 ->
      Dataset %ntrain %ntest %imgdim2 %labeldim2
    )
    external (builtin = "dataset_helper__gen_map", surface = "map")
  val ~gen_print_summary :
    {ntrain : Nat} ->
    {ntest : Nat} ->
    {imgdim : List Nat} ->
    {labeldim : List Nat} ->
    &(Dataset %ntrain %ntest %imgdim %labeldim -> Unit)
    external (builtin = "dataset_helper__gen_print_summary", surface = "print_summary")
end

module MnistHelper = struct
  val ~image_height = 28 as Nat
  val ~image_width = 28 as Nat
  val ~image_dim = (28 * 28) as Nat
  val ~label_count = 10
  val ~num_train_images = 60000 as Nat
  val ~num_test_images = 10000 as Nat
  val dataset : Dataset %num_train_images %num_test_images %[image_dim] %[]
    external (builtin = "mnist_helper__dataset", surface = "dataset")
  val train_images : Tensor %[num_train_images, image_dim]
    external (builtin = "mnist_helper__train_images", surface = "train_images")
  val train_labels : Tensor %[num_train_images]
    external (builtin = "mnist_helper__train_labels", surface = "train_labels")
  val test_images : Tensor %[num_test_images, image_dim]
    external (builtin = "mnist_helper__test_images", surface = "test_images")
  val test_labels : Tensor %[num_test_images]
    external (builtin = "mnist_helper__test_labels", surface = "test_labels")
end

module Module = struct
  val ~gen_load : {ns : List Nat} -> String -> &(List (Tensor %ns) -> Tensor %ns)
    external (builtin = "module__gen_load", surface = "load")
  val ~gen_forward : {ns : List Nat} -> &((List (Tensor %ns) -> Tensor %ns) -> List (Tensor %ns) -> Tensor %ns)
    external (builtin = "module__gen_forward", surface = "forward")
end

module TextHelper = struct
  val ~gen_create : {labels : Nat} -> #filename String -> &(TextHelper %labels)
    external (builtin = "text_helper__gen_create", surface = "create")
  val ~gen_char : {labels : Nat} -> &(TextHelper %labels -> #label Int -> Char)
    external (builtin = "text_helper__gen_char", surface = "char")
  val ~gen_total_length : {labels : Nat} -> &(TextHelper %labels -> Int)
    external (builtin = "text_helper__gen_total_length", surface = "total_length")
  val ~gen_iter :
    {labels : Nat} ->
    #seq_len (seq_len : Nat) ->
    #batch_size (batch_size : Nat) ->
    &((Int -> #xs Tensor %[batch_size, seq_len] -> #ys Tensor %[batch_size, seq_len] -> Unit) ->
      #device Device ->
      TextHelper %labels ->
      Unit
    )
    external (builtin = "text_helper__gen_iter", surface = "iter")
end

module TorchVision = struct
  module Resnet = struct
    val ~gen_resnet18 :
      {image_shape : {s : List Nat | List.length s == 4 && List.nth 1 s == 3}} ->
      #num_classes (num_classes : Nat) -> (* default: 512 *)
      &(VarStore ->
        #is_training Bool ->
        Tensor %image_shape ->
        Tensor %[List.nth 0 image_shape, num_classes]
      )
      external (builtin = "torch_vision__resnet__gen_resnet18", surface = "resnet18")
  end
  module Imagenet = struct
    val ~gen_load_dataset :
      {ntrain : Nat} ->
      {ntest : Nat} ->
      {imgdim : List Nat} ->
      {labels : List Nat} ->
      #dir String ->
      #classes List String ->
      (* #with_cache String -> *)
      &(Unit -> Dataset %ntrain %ntest %imgdim %labels)
      external (builtin = "torch_vision__imagenet__gen_load_dataset", surface = "load_dataset")
    val ~gen_load_image :
      {ns : List Nat} ->
      (* #resize Int * Int -> *)
      String ->
      &(Tensor %ns)
      external (builtin = "torch_vision__imagenet__gen_load_image", surface = "load_image")
    module Classes = struct
      val ~count = 1000 as Nat
      val ~names : List String
        external (builtin = "torch_vision__imagenet__classes__names", surface = "names")
      val ~gen_top :
        {shape : {sh : List Nat | reshapeable sh [1000]}} ->
        #k Int ->
        &(Tensor %shape -> List (String * Float))
        external (builtin = "torch_vision__imagenet__classes__gen_top", surface = "top")
    end
  end
  module Vgg = struct
    val ~gen_vgg11 :
      {image_shape : {s : List Nat | List.length s == 4 && List.nth 1 s == 3}} ->
      #num_classes (num_classes : Nat) ->
      &(VarStore ->
        #is_training Bool ->
        Tensor %image_shape ->
        Tensor %[List.nth 0 image_shape, num_classes]
      )
      external (builtin = "torch_vision__vgg__gen_vgg11", surface = "vgg11")
  end
end

module Serialize = struct
  val ~gen_load_multi_ :
    {ns : List Nat} ->
    #filename String ->
    &(#named_tensors List (String * Tensor %ns) ->
      Unit
    )
    external (builtin = "serialize__gen_load_multi_", surface = "load_multi_")
end
