val %( + ) : Int -> Int -> Int
  external (builtin = "int_add", surface = "+")
val %( - ) : Int -> Int -> Int
  external (builtin = "int_sub", surface = "-")
val %( * ) : Int -> Int -> Int
  external (builtin = "int_mult", surface = "*")
val %( // ) : Int -> Int -> Int
  external (builtin = "int_div", surface = "//")
val %( / ) : Float -> Float -> Float
  external (builtin = "float_div", surface = "/")
val %mod : Int -> Int -> Int
  external (builtin = "int_mod", surface = "mod")
val %( <= ) : Int -> Int -> Bool
  external (builtin = "int_leq", surface = "<=")
val %( == ) : Int -> Int -> Bool
  external (builtin = "int_equal", surface = "==")
val %( && ) : Bool -> Bool -> Bool
  external (builtin = "and", surface = "&&")
val %( :: ) : forall 'a -> 'a -> List 'a -> List 'a
  external (builtin = "cons", surface = "::")
val %float : Int -> Float
  external (builtin = "float", surface = "float")
val %print_float : Float -> Unit
  external (builtin = "print_float", surface = "print_float")
val %print_string : String -> Unit
  external (builtin = "print_string", surface = "print_string")
val %range : Int -> Int -> List Int
  external (builtin = "range", surface = "range")
val %fst : forall 'a -> forall 'b -> 'a * 'b -> 'a
  external (builtin = "fst", surface = "fst")
val %snd : forall 'a -> forall 'b -> 'a * 'b -> 'b
  external (builtin = "snd", surface = "snd")

val ~lift_string : String -> &String
  external (builtin = "lift_string", surface = "lift_string")

val ~drop_at : Nat -> List Nat -> List Nat
  external (builtin = "drop_at", surface = "drop_at")
val ~broadcastable : List Nat -> List Nat -> Bool
  external (builtin = "broadcastable", surface = "broadcastable")
val ~broadcast : List Nat -> List Nat -> List Nat
  external (builtin = "broadcast", surface = "broadcast")
(* TODO: make `reshapeable` support `-1` *)
val ~reshapeable : List Nat -> List Nat -> Bool
  external (builtin = "reshapeable", surface = "reshapeable")

val ~gen_vadd : {a : Nat} -> &(Vec %a -> Vec %a -> Vec %a)
  external (builtin = "gen_vadd", surface = "vadd")
val ~gen_vconcat : {a : Nat} -> {b : Nat} -> &(Vec %a -> Vec %b -> Vec %(a + b))
  external (builtin = "gen_vconcat", surface = "vconcat")
val ~gen_mtranspose : {a : Nat} -> {b : Nat} -> &(Mat %a %b -> Mat %b %a)
  external (builtin = "gen_mtranspose", surface = "mtranspose")
val ~gen_mmult : {a : Nat} -> {b : Nat} -> {c : Nat} -> &(Mat %a %b -> Mat %b %c -> Mat %a %c)
  external (builtin = "tensor__gen_mm", surface = "mmult")
    (* TODO: replace this with `Tensor.gen_mm` *)
val ~gen_mconcat_vert : {a : Nat} -> {b : Nat} -> {c : Nat} -> &(Mat %a %c -> Mat %b %c -> Mat %(a + b) %c)
  external (builtin = "gen_mconcat_vert", surface = "mconcat_vert")

module List = struct
  val %map : forall 'a -> forall 'b -> ('a -> 'b) -> List 'a -> List 'b
    external (builtin = "list__map", surface = "map")
  val %append : forall 'a -> List 'a -> List 'a -> List 'a
    external (builtin = "list__append", surface = "append")
  val %iter : forall 'a -> ('a -> Unit) -> List 'a -> Unit
    external (builtin = "list__iter", surface = "iter")
  val %length : forall 'a -> List 'a -> Int
    external (builtin = "list__length", surface = "length")
end

module Device = struct
  val cpu : Device
    external (builtin = "device__cpu", surface = "cpu")
  val ~gen_cuda_if_available : Unit -> &Device
    external (builtin = "device__gen_cuda_if_available", surface = "cuda_if_available")
end

module Tensor = struct
  val ~gen_zeros : (shape : List Nat) -> &(Tensor %shape)
    external (builtin = "tensor__gen_zeros", surface = "zeros")
  val ~gen_copy : {shape : List Nat} -> &(Tensor %shape -> Tensor %shape)
    external (builtin = "tensor__gen_copy", surface = "copy")
  val ~gen_add :
    {shape1 : List Nat} -> {shape2 : {s : List Nat | broadcastable shape1 s}} ->
    &(Tensor %shape1 -> Tensor %shape2 -> Tensor %(broadcast shape1 shape2))
    external (builtin = "tensor__gen_add", surface = "+")
  val ~gen_mult :
    {shape1 : List Nat} -> {shape2 : {s : List Nat | broadcastable shape1 s}} ->
    &(Tensor %shape1 -> Tensor %shape2 -> Tensor %(broadcast shape1 shape2))
    external (builtin = "tensor__gen_mult", surface = "*")
  val ~gen_grad : {shape : List Nat} -> &(Tensor %shape -> Tensor %shape)
    external (builtin = "tensor__gen_grad", surface = "grad")
  val ~gen_zero_grad : {shape : List Nat} -> &(Tensor %shape -> Unit)
    external (builtin = "tensor__gen_zero_grad", surface = "zero_grad")
  val ~gen_mm : {a : Nat} -> {b : Nat} -> {c : Nat} -> &(Mat %a %b -> Mat %b %c -> Mat %a %c)
    external (builtin = "tensor__gen_mm", surface = "mm")
  val ~gen_add_update : {shape : List Nat} -> &(Tensor %shape -> Tensor %shape -> Unit)
    external (builtin = "tensor__gen_add_update", surface = "+=")
  val ~gen_sub_update : {shape : List Nat} -> &(Tensor %shape -> Tensor %shape -> Unit)
    external (builtin = "tensor__gen_sub_update", surface = "-=")
  val ~gen_argmax : {shape : List Nat} -> (dim : Nat) -> &(Tensor %shape -> Tensor %(drop_at dim shape))
    external (builtin = "tensor__gen_argmax", surface = "argmax")
  val ~gen_cross_entropy_for_logits :
    {m : Nat} -> {n : Nat} ->
    &(Tensor %[m, n] -> Tensor %[m] -> Tensor %[])
    external (builtin = "tensor__gen_cross_entropy_for_logits", surface = "cross_entropy_for_logits")
  val ~gen_count_equal : {shape : List Nat} -> &(Tensor %shape -> Tensor %shape -> Int)
    external (builtin = "tensor__gen_count_equal", surface = "count_equal")
  val f : Float -> Tensor %[]
    external (builtin = "tensor__f", surface = "f")
  val backward : Tensor %[] -> Unit
    external (builtin = "tensor__backward", surface = "backward")
  val no_grad : (Unit -> Unit) -> Unit
    external (builtin = "tensor__no_grad", surface = "no_grad")
  val float_value : Tensor %[] -> Float
    external (builtin = "tensor__float_value", surface = "float_value")
  val ~gen_dropout :
    {shape : List Nat} ->
    &(#p Float -> (* dropout prob *)
      #is_training Bool ->
      Tensor %shape ->
      Tensor %shape
    )
    external (builtin = "tensor__gen_dropout", surface = "dropout")
  (* TODO: make `gen_reshape` support `-1` *)
  val ~gen_reshape :
    {shape1 : List Nat} ->
    (shape2 : {sh : List Nat | reshapeable shape1 sh}) ->
    &(Tensor %shape1 ->
      Tensor %shape2
    )
    external (builtin = "tensor__gen_reshape", surface = "reshape")
  val ~gen_max_pool2d :
    {k : Nat} ->
    {l : Nat} ->
    {m : Nat} ->
    {n : Nat} ->
    #padding (padding : Int * Int) ->
    #ksize (ksize : Int * Int) ->
    #stride (stride : Int * Int) ->
    &(Tensor %[k, l, m, n] ->
      Tensor %[k, l, (m + 2 * fst padding - fst ksize) // fst stride + 1, (n + 2 * snd padding - snd ksize) // snd stride + 1]
    )
    external (builtin = "tensor__gen_max_pool2d", surface = "max_pool2d")
  val ~gen_softmax :
    {ns : List Nat} ->
    #dim Int ->
    &(Tensor %ns -> Tensor %ns)
    external (builtin = "tensor__gen_softmax", surface = "softmax")
end

module VarStore = struct
  val create :
    #frozen Bool ->
    #name String ->
    #device Device ->
    Unit -> VarStore
    external (builtin = "var_store__create", surface = "create")
  val freeze : VarStore -> Unit
    external (builtin = "var_store__freeze", surface = "freeze")
  val unfreeze : VarStore -> Unit
    external (builtin = "var_store__unfreeze", surface = "unfreeze")
  val ~gen_all_vars : {ns : List Nat} -> &(VarStore -> List (String * Tensor %ns))
    external (builtin = "var_store__gen_all_vars", surface = "all_vars")
end

module Layer = struct
  module Activation = struct
    val relu : Activation
      external (builtin = "layer__activation__relu", surface = "relu")
    val none : Activation
      external (builtin = "layer__activation__none", surface = "none")
  end
  val ~gen_forward :
    {shape1 : List Nat} ->
    {shape2 : List Nat} ->
    &((Tensor %shape1 -> Tensor %shape2) ->
      Tensor %shape1 -> Tensor %shape2
    )
    external (builtin = "layer__gen_forward", surface = "forward")
  val ~gen_forward_ :
    {shape1 : List Nat} ->
    {shape2 : List Nat} ->
    &((Tensor %shape1 -> #is_training Bool -> Tensor %shape2) ->
      Tensor %shape1 -> #is_training Bool -> Tensor %shape2
    )
    external (builtin = "layer__gen_forward_", surface = "forward_")
  val ~gen_conv2d_ :
    {l : Nat} ->
    {m : Nat} ->
    {n : Nat} ->
    #ksize (ksize : Int) ->
    #stride (stride : Int) ->
    #padding (padding : Int) ->
    #input_dim (input_dim : Nat) ->
    #output_dim (output_dim : Nat) ->
    &(VarStore ->
      Tensor %[l, input_dim, m, n] ->
      Tensor %[l, output_dim, (m + 2 * padding - ksize) // stride + 1, (n + 2 * padding - ksize) // stride + 1]
    )
    external (builtin = "layer__gen_conv2d_", surface = "conv2d_")
  val ~gen_linear :
    {ns : List Nat} ->
    #input_dim (input_dim : Nat) ->
    #output_dim (output_dim : Nat) ->
    &(VarStore ->
      Activation ->
      Tensor %(List.append ns [input_dim]) ->
      Tensor %(List.append ns [output_dim])
    )
    external (builtin = "layer__gen_linear", surface = "linear")
end

module Optimizer = struct
  val adam :
    VarStore ->
    #learning_rate Float ->
    Optimizer
    external (builtin = "optimizer__adam", surface = "adam")
  val sgd :
    VarStore ->
    #learning_rate Float ->
    #momentum Float ->
    Optimizer
    external (builtin = "optimizer__sgd", surface = "sgd")
  val backward_step :
    Optimizer ->
    #loss Tensor %[] ->
    Unit
    external (builtin = "optimizer__backward_step", surface = "backward_step")
end

module DatasetHelper = struct
  val ~gen_train_batch :
    {ntrain : Nat} ->
    {ntest : Nat} ->
    {imgdim : List Nat} ->
    {labeldim : List Nat} ->
    #batch_size (batch_size : Nat) ->
    &(Device ->
      Dataset %ntrain %ntest %imgdim %labeldim ->
      Int ->
      Tensor %(batch_size :: imgdim) * Tensor %(batch_size :: labeldim)
    )
    external (builtin = "dataset_helper__gen_train_batch", surface = "train_batch")
  val ~gen_batch_accuracy :
    {ntrain : Nat} ->
    {ntest : Nat} ->
    {imgdim : List Nat} ->
    {labeldim : List Nat} ->
    {n : Nat} ->
    #batch_size (batch_size : Nat) ->
    #predict ((actual_batch_size : Nat) ->
      &(Tensor %(actual_batch_size :: imgdim) -> Tensor %[actual_batch_size, n])
    ) ->
    &(Device -> Dataset %ntrain %ntest %imgdim %labeldim -> Float)
    external (builtin = "dataset_helper__gen_batch_accuracy", surface = "batch_accuracy")
  val ~gen_batches_per_epoch :
    {ntrain : Nat} ->
    {ntest : Nat} ->
    {imgdim : List Nat} ->
    {labeldim : List Nat} ->
    #batch_size (batch_size : Nat) ->
    &(Dataset %ntrain %ntest %imgdim %labeldim -> Int)
    external (builtin = "dataset_helper__gen_batches_per_epoch", surface = "batches_per_epoch")
  val ~gen_iter :
    {ntrain : Nat} ->
    {ntest : Nat} ->
    {imgdim : List Nat} ->
    {labeldim : List Nat} ->
    #batch_size (batch_size : Nat) ->
    ((actual_batch_size : Nat) ->
      &(Tensor %(actual_batch_size :: imgdim) -> Tensor %(actual_batch_size :: labeldim) -> Unit)
    ) ->
    &(Device -> Dataset %ntrain %ntest %imgdim %labeldim -> Unit)
    external (builtin = "dataset_helper__gen_iter", surface = "iter")
  val ~gen_map :
    {ntrain : Nat} ->
    {ntest : Nat} ->
    {imgdim : List Nat} ->
    {labeldim : List Nat} ->
    #batch_size (batch_size : Nat) ->
    ((actual_batch_size : Nat) ->
      &(Tensor %(actual_batch_size :: imgdim) -> Tensor %(actual_batch_size :: labeldim) ->
          Tensor %(actual_batch_size :: imgdim) * Tensor %(actual_batch_size :: labeldim)
      )
    ) ->
    &(Device -> Dataset %ntrain %ntest %imgdim %labeldim -> Dataset %ntrain %ntest %imgdim %labeldim)
    external (builtin = "dataset_helper__gen_map", surface = "map")
  val ~gen_print_summary :
    {ntrain : Nat} ->
    {ntest : Nat} ->
    {imgdim : List Nat} ->
    {labeldim : List Nat} ->
    &(Dataset %ntrain %ntest %imgdim %labeldim -> Unit)
    external (builtin = "dataset_helper__gen_print_summary", surface = "print_summary")
end

module MnistHelper = struct
  val ~image_dim = (28 * 28) as Nat
  val ~label_count = 10
  val dataset : Dataset %60000 %10000 %[image_dim] %[]
    external (builtin = "mnist_helper__dataset", surface = "dataset")
  val train_images : Tensor %[60000, image_dim]
    external (builtin = "mnist_helper__train_images", surface = "train_images")
  val train_labels : Tensor %[60000]
    external (builtin = "mnist_helper__train_labels", surface = "train_labels")
  val num_test_images = 10000
  val test_images : Tensor %[10000, image_dim]
    external (builtin = "mnist_helper__test_images", surface = "test_images")
  val test_labels : Tensor %[10000]
    external (builtin = "mnist_helper__test_labels", surface = "test_labels")
end

module Module = struct
  val ~gen_load : {ns : List Nat} -> String -> &(List (Tensor %ns) -> Tensor %ns)
    external (builtin = "module__gen_load", surface = "load")
  val ~gen_forward : {ns : List Nat} -> &((List (Tensor %ns) -> Tensor %ns) -> List (Tensor %ns) -> Tensor %ns)
    external (builtin = "module__gen_forward", surface = "forward")
end

module TorchVision = struct
  module Resnet = struct
    val ~gen_resnet18 :
      {dim0 : Nat} ->
      {dim2 : Nat} ->
      {dim3 : Nat} ->
      #num_classes (num_classes : Nat) -> (* default: 512 *)
      &(VarStore ->
        Tensor %[dim0, 3, dim2, dim3] ->
        #is_training Bool ->
        Tensor %[dim0, num_classes]
      )
      external (builtin = "torch_vision__resnet__gen_resnet18", surface = "resnet18")
  end
  module Imagenet = struct
    val ~gen_load_dataset :
      {ntrain : Nat} ->
      {ntest : Nat} ->
      {imgdim : Nat} ->
      #dir String ->
      #classes List String ->
      (* #with_cache String -> *)
      &(Unit -> Dataset %ntrain %ntest %[imgdim] %[])
      external (builtin = "torch_vision__imagenet__gen_load_dataset", surface = "load_dataset")
    val ~load_image :
      {ns : List Nat} ->
      (* #resize Int * Int -> *)
      String ->
      &(Tensor %ns)
      external (builtin = "torch_vision__imagenet__load_image", surface = "load_image")
    module Classes = struct
      val ~count = 1000 as Nat
      val ~names : List String
        external (builtin = "torch_vision__imagenet__classes__names", surface = "names")
      val ~gen_top :
        #k Int ->
        &(Tensor %[1000] -> List (String * Float))
        external (builtin = "torch_vision__imagenet__classes__gen_top", surface = "top")
    end
  end
end

module Serialize = struct
  val ~gen_load_multi_ :
    {ns : List Nat} ->
    #filename String ->
    &(#named_tensors List (String * Tensor %ns) ->
      Unit
    )
    external (builtin = "serialize__gen_load_multi_", surface = "load_multi_")
end
